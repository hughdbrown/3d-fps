<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First Person Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
            cursor: pointer;
        }
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #menu.hidden {
            display: none;
        }
        .menu-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
        }
        .menu-container h1 {
            margin: 0 0 30px 0;
            color: #333;
            text-align: center;
        }
        .setting-group {
            margin-bottom: 25px;
        }
        .setting-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: bold;
        }
        .setting-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        .setting-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        .setting-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
        .setting-group select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 16px;
            background: white;
            cursor: pointer;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #667eea;
            font-weight: bold;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }
        #startButton {
            width: 100%;
            padding: 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }
        #startButton:hover {
            background: #5568d3;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }
        #instructions.hidden {
            display: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
        }
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 50;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            transition: all 0.2s;
        }
        .hotbar-slot.selected {
            border-color: white;
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        .hotbar-block {
            width: 35px;
            height: 35px;
            border-radius: 3px;
        }
        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 50;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="menu">
        <div class="menu-container">
            <h1>Block Builder</h1>

            <div class="setting-group">
                <label>Walk Speed <span class="value-display" id="speedValue">20</span></label>
                <input type="range" id="speedSlider" min="10" max="50" value="20" step="5">
            </div>

            <div class="setting-group">
                <label>Mouse Sensitivity <span class="value-display" id="sensitivityValue">1.0</span></label>
                <input type="range" id="sensitivitySlider" min="0.5" max="2.0" value="1.0" step="0.1">
            </div>

            <div class="setting-group">
                <label>FOV <span class="value-display" id="fovValue">75</span></label>
                <input type="range" id="fovSlider" min="60" max="110" value="75" step="5">
            </div>

            <div class="setting-group">
                <label>World Size</label>
                <select id="worldSizeSelect">
                    <option value="25">Small (25x25)</option>
                    <option value="100" selected>Medium (100x100)</option>
                    <option value="200">Large (200x200)</option>
                </select>
            </div>

            <div class="setting-group">
                <label>World Seed <span class="value-display" id="seedValue">12345</span></label>
                <input type="range" id="seedSlider" min="1" max="99999" value="12345" step="1">
            </div>

            <div class="setting-group">
                <label>Render Distance <span class="value-display" id="renderDistanceValue">6</span> chunks</label>
                <input type="range" id="renderDistanceSlider" min="1" max="12" value="6" step="1">
            </div>

            <div class="setting-group">
                <label style="margin-bottom: 15px;">Graphics Options</label>
                <div class="checkbox-group">
                    <input type="checkbox" id="bloomToggle">
                    <label for="bloomToggle">Enable Bloom</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="reflectionsToggle">
                    <label for="reflectionsToggle">Enable Reflections</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="shadowsToggle" checked>
                    <label for="shadowsToggle">Enable Shadows</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="sunGlareToggle">
                    <label for="sunGlareToggle">Sun Glare</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="moonGlareToggle">
                    <label for="moonGlareToggle">Moon Glare</label>
                </div>
            </div>

            <button id="startButton">Start Game</button>
        </div>
    </div>

    <div id="instructions">
        <h2>First Person Game</h2>
        <p>Click to start</p>
        <p>Move: WASD or Arrow Keys</p>
        <p>Jump: Space Bar</p>
        <p>Look: Move Mouse</p>
        <p>Scroll: Select Block</p>
        <p>Left Click: Destroy Block</p>
        <p>Right Click: Place Block</p>
        <p>ESC to unlock cursor</p>
    </div>
    <div id="crosshair"></div>
    <div id="hotbar"></div>
    <div id="debug"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // CONSTANTS
        // ============================================
        const PLAYER_HEIGHT = 1.8;
        const PLAYER_RADIUS = 0.5;
        const GRAVITY = 30;
        const JUMP_VELOCITY = 12;
        const BLOCK_SIZE = 1;
        const REACH_DISTANCE = 10;
        const CHUNK_SIZE = 16;

        // ============================================
        // GAME STATE
        // ============================================
        let scene, camera, renderer;
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let canJump = false;
        let velocity, direction;

        let yaw = 0, pitch = 0;
        let isLocked = false;
        let prevTime = performance.now();

        let MOVE_SPEED = 20;
        let MOUSE_SENSITIVITY = 1.0;

        // Graphics settings
        let bloomEnabled = false;
        let reflectionsEnabled = false;
        let shadowsEnabled = true;

        // World data
        let worldSize = 100;
        let worldSeed = 12345;
        let heightMap = [];      // Procedural terrain heights [x][z] -> height
        let voxelData = {};      // Modified voxels: key -> blockType (0 = destroyed)
        let chunks = {};         // Chunk meshes: chunkKey -> THREE.Mesh

        // Block types with colors
        const BLOCK_GRASS = 1;
        const BLOCK_DIRT = 2;
        const BLOCK_STONE = 3;

        const blockColors = {
            [BLOCK_GRASS]: new THREE.Color(0x228B22),
            [BLOCK_DIRT]: new THREE.Color(0x8B4513),
            [BLOCK_STONE]: new THREE.Color(0x808080),
            4: new THREE.Color(0x808080),  // Stone (hotbar)
            5: new THREE.Color(0x8B4513),  // Wood
            6: new THREE.Color(0xB22222),  // Brick
            7: new THREE.Color(0xFFD700),  // Gold
            8: new THREE.Color(0x228B22),  // Grass (hotbar)
            9: new THREE.Color(0xADD8E6),  // Ice
            10: new THREE.Color(0xF4A460), // Sand
            11: new THREE.Color(0x1C1C1C)  // Obsidian
        };

        const blockTypes = [
            { name: 'Stone', color: 0x808080, id: 4 },
            { name: 'Wood', color: 0x8B4513, id: 5 },
            { name: 'Brick', color: 0xB22222, id: 6 },
            { name: 'Gold', color: 0xFFD700, id: 7 },
            { name: 'Grass', color: 0x228B22, id: 8 },
            { name: 'Ice', color: 0xADD8E6, id: 9 },
            { name: 'Sand', color: 0xF4A460, id: 10 },
            { name: 'Obsidian', color: 0x1C1C1C, id: 11 }
        ];

        let selectedBlockIndex = 0;

        // Stats
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let totalFaces = 0;

        // Lighting (stored for shadow updates)
        let sunLight = null;
        let RENDER_DISTANCE = 6; // In chunks

        // Day-night cycle
        let timeOfDay = 0.25; // 0 = midnight, 0.25 = sunrise, 0.5 = noon, 0.75 = sunset, 1.0 = midnight
        let dayCount = 0; // Track number of days passed
        const DAY_CYCLE_DURATION = 1200; // seconds for full day-night cycle (20 minutes)
        const DAYS_PER_SEASON = 5;
        let sunSphere = null;
        let moonSphere = null;
        let moonLight = null;
        let sunGlareSprite = null;
        let moonGlareSprite = null;
        let starField = null;

        // Glare settings
        let sunGlareEnabled = false;
        let moonGlareEnabled = false;
        const MOON_LIGHT_INTENSITY = 0.12; // Constant moon brightness (diffuse)

        // Season definitions (0=Spring, 1=Summer, 2=Autumn, 3=Winter)
        function getCurrentSeason() {
            return Math.floor((dayCount % (DAYS_PER_SEASON * 4)) / DAYS_PER_SEASON);
        }

        function getSeasonName(season) {
            return ['Spring', 'Summer', 'Autumn', 'Winter'][season];
        }

        // Season affects sun arc height and day length
        function getSeasonalSunParams() {
            const season = getCurrentSeason();
            const dayInSeason = dayCount % DAYS_PER_SEASON;
            const seasonProgress = dayInSeason / DAYS_PER_SEASON;

            // Base values that vary by season
            // maxSunAngle: how high the sun gets (affects arc height)
            // dayLengthMultiplier: how long daytime is relative to night
            let maxSunAngle, dayLengthMultiplier;

            switch (season) {
                case 0: // Spring - transitioning to longer days
                    maxSunAngle = 0.6 + seasonProgress * 0.2; // 0.6 to 0.8
                    dayLengthMultiplier = 1.0 + seasonProgress * 0.2; // 1.0 to 1.2
                    break;
                case 1: // Summer - longest days, highest sun
                    maxSunAngle = 0.8 + seasonProgress * 0.1; // 0.8 to 0.9
                    dayLengthMultiplier = 1.2 + seasonProgress * 0.1; // 1.2 to 1.3
                    break;
                case 2: // Autumn - transitioning to shorter days
                    maxSunAngle = 0.9 - seasonProgress * 0.3; // 0.9 to 0.6
                    dayLengthMultiplier = 1.3 - seasonProgress * 0.4; // 1.3 to 0.9
                    break;
                case 3: // Winter - shortest days, lowest sun
                    maxSunAngle = 0.6 - seasonProgress * 0.2; // 0.6 to 0.4
                    dayLengthMultiplier = 0.9 - seasonProgress * 0.2; // 0.9 to 0.7
                    break;
            }

            return { maxSunAngle, dayLengthMultiplier };
        }

        // ============================================
        // FACE DEFINITIONS (CCW winding for front-face)
        // Each face has: direction normal, corner offsets
        // Corners are in counter-clockwise order when viewed from outside
        // ============================================
        const FACES = [
            // Top (+Y): looking from above
            { dir: [0, 1, 0], corners: [[0,1,0], [0,1,1], [1,1,1], [1,1,0]] },
            // Bottom (-Y): looking from below
            { dir: [0, -1, 0], corners: [[0,0,0], [1,0,0], [1,0,1], [0,0,1]] },
            // Right (+X): looking from right
            { dir: [1, 0, 0], corners: [[1,0,0], [1,1,0], [1,1,1], [1,0,1]] },
            // Left (-X): looking from left
            { dir: [-1, 0, 0], corners: [[0,0,1], [0,1,1], [0,1,0], [0,0,0]] },
            // Front (+Z): looking from front
            { dir: [0, 0, 1], corners: [[1,0,1], [1,1,1], [0,1,1], [0,0,1]] },
            // Back (-Z): looking from back
            { dir: [0, 0, -1], corners: [[0,0,0], [0,1,0], [1,1,0], [1,0,0]] }
        ];

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function getVoxelKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        function getChunkKey(cx, cz) {
            return `${cx},${cz}`;
        }

        function worldToChunk(x, z) {
            return {
                cx: Math.floor(x / CHUNK_SIZE),
                cz: Math.floor(z / CHUNK_SIZE)
            };
        }

        function worldToLocal(x, z) {
            // Convert world voxel coords to heightMap coords
            const halfSize = worldSize / 2;
            return {
                lx: Math.floor(x + halfSize),
                lz: Math.floor(z + halfSize)
            };
        }

        // ============================================
        // TERRAIN GENERATION
        // ============================================
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            random() {
                const x = Math.sin(this.seed++) * 10000;
                return x - Math.floor(x);
            }
        }

        function noise2D(x, z, seed) {
            const X = Math.floor(x);
            const Z = Math.floor(z);
            const xf = x - X;
            const zf = z - Z;

            const u = xf * xf * (3 - 2 * xf);
            const v = zf * zf * (3 - 2 * zf);

            const hash = (i, j) => {
                const n = i * 374761393 + j * 668265263;
                return (Math.sin(n + seed) * 43758.5453) % 1;
            };

            const a = hash(X, Z);
            const b = hash(X + 1, Z);
            const c = hash(X, Z + 1);
            const d = hash(X + 1, Z + 1);

            const x1 = a + u * (b - a);
            const x2 = c + u * (d - c);

            return x1 + v * (x2 - x1);
        }

        function generateHeightMap() {
            const scale = 0.05;
            const heightVariation = 15;
            const baseHeight = 35;

            heightMap = [];
            for (let x = 0; x < worldSize; x++) {
                heightMap[x] = [];
                for (let z = 0; z < worldSize; z++) {
                    let height = 0;
                    height += noise2D(x * scale, z * scale, worldSeed) * heightVariation;
                    height += noise2D(x * scale * 2, z * scale * 2, worldSeed) * (heightVariation / 2);
                    height += noise2D(x * scale * 4, z * scale * 4, worldSeed) * (heightVariation / 4);
                    heightMap[x][z] = Math.floor(baseHeight + height);
                }
            }
        }

        // ============================================
        // VOXEL ACCESS
        // ============================================
        function getTerrainHeight(wx, wz) {
            // wx, wz are world voxel coordinates (can be negative)
            const { lx, lz } = worldToLocal(wx, wz);
            if (lx < 0 || lx >= worldSize || lz < 0 || lz >= worldSize) {
                return 0;
            }
            return heightMap[lx][lz];
        }

        function getVoxel(x, y, z) {
            // Check modified voxels first
            const key = getVoxelKey(x, y, z);
            if (key in voxelData) {
                return voxelData[key]; // Could be 0 for destroyed blocks
            }

            // Fall back to procedural terrain
            if (y < 1) return 0;

            const terrainHeight = getTerrainHeight(x, z);
            if (terrainHeight === 0 || y > terrainHeight) {
                return 0;
            }

            const depthFromSurface = terrainHeight - y;
            if (depthFromSurface === 0) {
                return BLOCK_GRASS;
            } else if (depthFromSurface <= 4) {
                return BLOCK_DIRT;
            } else {
                return BLOCK_STONE;
            }
        }

        function setVoxel(x, y, z, blockType) {
            const key = getVoxelKey(x, y, z);
            voxelData[key] = blockType; // Store explicitly, even if 0

            // Rebuild affected chunks
            const { cx, cz } = worldToChunk(x, z);
            rebuildChunk(cx, cz);

            // Check if we're at chunk boundary and need to rebuild neighbors
            const localX = x - cx * CHUNK_SIZE;
            const localZ = z - cz * CHUNK_SIZE;

            if (localX === 0) rebuildChunk(cx - 1, cz);
            if (localX === CHUNK_SIZE - 1) rebuildChunk(cx + 1, cz);
            if (localZ === 0) rebuildChunk(cx, cz - 1);
            if (localZ === CHUNK_SIZE - 1) rebuildChunk(cx, cz + 1);
        }

        // ============================================
        // CHUNK MESH GENERATION
        // ============================================
        function createChunkMesh(cx, cz) {
            const positions = [];
            const normals = [];
            const colors = [];
            const indices = [];

            const startX = cx * CHUNK_SIZE;
            const startZ = cz * CHUNK_SIZE;

            let faceCount = 0;

            // Track which voxels we've processed to avoid duplicates
            const processedVoxels = new Set();

            // Helper to add a block's visible faces
            function addBlockFaces(x, y, z) {
                const voxelKey = getVoxelKey(x, y, z);
                if (processedVoxels.has(voxelKey)) return;
                processedVoxels.add(voxelKey);

                const blockType = getVoxel(x, y, z);
                if (!blockType) return;

                const color = blockColors[blockType] || new THREE.Color(0xff00ff);

                // Check each face for visibility
                for (const face of FACES) {
                    const [dx, dy, dz] = face.dir;
                    const neighbor = getVoxel(x + dx, y + dy, z + dz);

                    // Only render face if neighbor is empty (0)
                    if (neighbor !== 0) continue;

                    const ndx = positions.length / 3;

                    // Add vertices for this face
                    // Block at voxel (x,y,z) spans from (x-0.5, y-1, z-0.5) to (x+0.5, y, z+0.5)
                    for (const [cornerX, cornerY, cornerZ] of face.corners) {
                        positions.push(
                            x + cornerX - 0.5,
                            (y - 1) + cornerY,
                            z + cornerZ - 0.5
                        );
                        normals.push(dx, dy, dz);
                        colors.push(color.r, color.g, color.b);
                    }

                    // Add indices (two triangles per face)
                    indices.push(
                        ndx, ndx + 1, ndx + 2,
                        ndx, ndx + 2, ndx + 3
                    );

                    faceCount++;
                }
            }

            // Process procedural terrain blocks
            for (let x = startX; x < startX + CHUNK_SIZE; x++) {
                for (let z = startZ; z < startZ + CHUNK_SIZE; z++) {
                    const terrainHeight = getTerrainHeight(x, z);
                    for (let y = 1; y <= terrainHeight; y++) {
                        addBlockFaces(x, y, z);
                    }
                }
            }

            // Process voxelData entries in this chunk (handles placed blocks above terrain)
            for (const key in voxelData) {
                const [vx, vy, vz] = key.split(',').map(Number);
                const { cx: blockCx, cz: blockCz } = worldToChunk(vx, vz);
                if (blockCx === cx && blockCz === cz && voxelData[key] !== 0) {
                    addBlockFaces(vx, vy, vz);
                }
            }

            totalFaces += faceCount;

            if (positions.length === 0) {
                return null;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);

            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: reflectionsEnabled ? 0.5 : 0.7,
                metalness: reflectionsEnabled ? 0.3 : 0
            });

            const mesh = new THREE.Mesh(geometry, material);
            if (shadowsEnabled) {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
            }

            return mesh;
        }

        // Track which chunks are currently active
        let activeChunks = new Set();

        function rebuildChunk(cx, cz) {
            const key = getChunkKey(cx, cz);

            // Remove old chunk mesh if exists
            if (chunks[key]) {
                scene.remove(chunks[key]);
                chunks[key].geometry.dispose();
                chunks[key].material.dispose();
                delete chunks[key];
            }

            // Only create mesh for active chunks (within render distance)
            if (!activeChunks.has(key)) {
                return;
            }

            const mesh = createChunkMesh(cx, cz);
            if (mesh) {
                chunks[key] = mesh;
                scene.add(mesh);
            }
        }

        function updateVisibleChunks(playerX, playerZ) {
            const { cx: playerCX, cz: playerCZ } = worldToChunk(playerX, playerZ);
            const halfSize = worldSize / 2;

            // Calculate world chunk bounds
            const minWorldCX = Math.floor(-halfSize / CHUNK_SIZE);
            const maxWorldCX = Math.ceil(halfSize / CHUNK_SIZE);
            const minWorldCZ = Math.floor(-halfSize / CHUNK_SIZE);
            const maxWorldCZ = Math.ceil(halfSize / CHUNK_SIZE);

            const newActiveChunks = new Set();

            // Determine which chunks should be visible
            for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                    const cx = playerCX + dx;
                    const cz = playerCZ + dz;

                    // Skip if outside world bounds
                    if (cx < minWorldCX || cx >= maxWorldCX || cz < minWorldCZ || cz >= maxWorldCZ) {
                        continue;
                    }

                    const key = getChunkKey(cx, cz);
                    newActiveChunks.add(key);

                    // Build chunk if not already built
                    if (!activeChunks.has(key)) {
                        activeChunks.add(key);
                        rebuildChunk(cx, cz);
                    }
                }
            }

            // Remove chunks that are no longer visible
            for (const key of activeChunks) {
                if (!newActiveChunks.has(key)) {
                    activeChunks.delete(key);
                    if (chunks[key]) {
                        scene.remove(chunks[key]);
                        chunks[key].geometry.dispose();
                        chunks[key].material.dispose();
                        delete chunks[key];
                    }
                }
            }

            activeChunks = newActiveChunks;
        }

        // ============================================
        // RAYCASTING FOR BLOCK INTERACTION
        // ============================================
        function getRaycastTarget() {
            const dir = new THREE.Vector3(0, 0, -1);
            dir.applyQuaternion(camera.quaternion);

            const step = 0.05;
            let prevX = null, prevY = null, prevZ = null;

            for (let d = 0; d < REACH_DISTANCE; d += step) {
                const pos = camera.position.clone().add(dir.clone().multiplyScalar(d));

                // Convert to voxel coordinates
                const vx = Math.floor(pos.x + 0.5);
                const vy = Math.floor(pos.y + 1);  // Adjust for coordinate system
                const vz = Math.floor(pos.z + 0.5);

                if (vx !== prevX || vy !== prevY || vz !== prevZ) {
                    const blockType = getVoxel(vx, vy, vz);
                    if (blockType !== 0) {
                        return {
                            voxel: { x: vx, y: vy, z: vz },
                            previous: prevX !== null ? { x: prevX, y: prevY, z: prevZ } : null
                        };
                    }
                    prevX = vx;
                    prevY = vy;
                    prevZ = vz;
                }
            }

            return null;
        }

        function placeBlock() {
            const target = getRaycastTarget();
            if (!target || !target.previous) return;

            const { x, y, z } = target.previous;

            // Check if position would collide with player
            // Block center is at (x, y-0.5, z), spans y-1 to y
            const blockWorldY = y - 0.5;
            const distToPlayer = Math.sqrt(
                Math.pow(x - camera.position.x, 2) +
                Math.pow(z - camera.position.z, 2)
            );

            // Player spans from camera.y - PLAYER_HEIGHT to camera.y + 0.3
            const playerBottom = camera.position.y - PLAYER_HEIGHT;
            const playerTop = camera.position.y + 0.3;
            const blockBottom = y - 1;
            const blockTop = y;

            const verticalOverlap = blockBottom < playerTop && blockTop > playerBottom;
            if (distToPlayer < PLAYER_RADIUS + 0.5 && verticalOverlap) {
                return;
            }

            // Check if block already exists
            if (getVoxel(x, y, z) !== 0) return;

            // Place the block
            const blockId = blockTypes[selectedBlockIndex].id;
            setVoxel(x, y, z, blockId);
        }

        function destroyBlock() {
            const target = getRaycastTarget();
            if (!target) return;

            const { x, y, z } = target.voxel;

            // Don't destroy if it's outside the world or already empty
            if (getVoxel(x, y, z) === 0) return;

            setVoxel(x, y, z, 0);
        }

        // ============================================
        // COLLISION DETECTION
        // ============================================
        function checkCollision(newPos) {
            // Check voxels around the player position
            const checkRadius = 2;

            for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                for (let dz = -checkRadius; dz <= checkRadius; dz++) {
                    for (let dy = -3; dy <= 2; dy++) {
                        const vx = Math.floor(newPos.x + 0.5) + dx;
                        const vy = Math.floor(newPos.y) + dy;
                        const vz = Math.floor(newPos.z + 0.5) + dz;

                        if (getVoxel(vx, vy, vz) === 0) continue;

                        // Block bounds (matching coordinate system)
                        const blockMinX = vx - 0.5;
                        const blockMaxX = vx + 0.5;
                        const blockMinY = vy - 1;
                        const blockMaxY = vy;
                        const blockMinZ = vz - 0.5;
                        const blockMaxZ = vz + 0.5;

                        // Player bounds
                        const playerMinX = newPos.x - PLAYER_RADIUS;
                        const playerMaxX = newPos.x + PLAYER_RADIUS;
                        const playerMinY = newPos.y - PLAYER_HEIGHT + 0.1;
                        const playerMaxY = newPos.y + 0.3;
                        const playerMinZ = newPos.z - PLAYER_RADIUS;
                        const playerMaxZ = newPos.z + PLAYER_RADIUS;

                        // AABB intersection test
                        if (playerMaxX > blockMinX && playerMinX < blockMaxX &&
                            playerMaxY > blockMinY && playerMinY < blockMaxY &&
                            playerMaxZ > blockMinZ && playerMinZ < blockMaxZ) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        // ============================================
        // STAR FIELD GENERATION
        // ============================================
        function createStarField() {
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);

            const radius = 500; // Distance of stars from center

            for (let i = 0; i < starCount; i++) {
                // Distribute stars on a sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);

                // Vary star colors slightly (white to blue-white to yellow-white)
                const colorVar = Math.random();
                if (colorVar < 0.7) {
                    // White stars
                    colors[i * 3] = 0.9 + Math.random() * 0.1;
                    colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
                    colors[i * 3 + 2] = 0.95 + Math.random() * 0.05;
                } else if (colorVar < 0.85) {
                    // Blue-white stars
                    colors[i * 3] = 0.7 + Math.random() * 0.2;
                    colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
                    colors[i * 3 + 2] = 1.0;
                } else {
                    // Yellow-white stars
                    colors[i * 3] = 1.0;
                    colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
                    colors[i * 3 + 2] = 0.7 + Math.random() * 0.2;
                }

                // Vary star sizes
                sizes[i] = 1.0 + Math.random() * 2.0;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0,
                fog: false,
                sizeAttenuation: false
            });

            const stars = new THREE.Points(geometry, material);
            return stars;
        }

        // ============================================
        // GLARE TEXTURE GENERATION
        // ============================================
        function createGlareTexture(intensity, falloff) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const centerX = 128;
            const centerY = 128;
            const radius = 128;

            // Create radial gradient for glare effect
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);

            // Sharp center fading to soft edges
            gradient.addColorStop(0, `rgba(255, 255, 255, ${intensity})`);
            gradient.addColorStop(0.1, `rgba(255, 255, 255, ${intensity * 0.8})`);
            gradient.addColorStop(0.3, `rgba(255, 255, 255, ${intensity * falloff * 0.5})`);
            gradient.addColorStop(0.6, `rgba(255, 255, 255, ${intensity * falloff * 0.2})`);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init(fov) {
            velocity = new THREE.Vector3();
            direction = new THREE.Vector3();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            // Fog starts fading at 70% of render distance, fully obscured at render distance
            const fogEnd = RENDER_DISTANCE * CHUNK_SIZE;
            const fogStart = fogEnd * 0.6;
            scene.fog = new THREE.Fog(0x87ceeb, fogStart, fogEnd);

            camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = shadowsEnabled;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = bloomEnabled ? 1.2 : 1.0;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // Sun light with shadows
            sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(50, 100, 50);

            if (shadowsEnabled) {
                const shadowFrustumSize = RENDER_DISTANCE * CHUNK_SIZE;
                sunLight.castShadow = true;
                sunLight.shadow.camera.left = -shadowFrustumSize;
                sunLight.shadow.camera.right = shadowFrustumSize;
                sunLight.shadow.camera.top = shadowFrustumSize;
                sunLight.shadow.camera.bottom = -shadowFrustumSize;
                sunLight.shadow.camera.near = 0.5;
                sunLight.shadow.camera.far = 300;
                sunLight.shadow.mapSize.width = 4096;
                sunLight.shadow.mapSize.height = 4096;
                // Bias pushes shadow depth, normalBias pushes along surface normal
                // Higher normalBias compensates shadows into the block to prevent edge bleeding
                sunLight.shadow.bias = 0;
                sunLight.shadow.normalBias = 0.15;
            }

            scene.add(sunLight);
            scene.add(sunLight.target);

            // Create visible sun sphere (hidden if glare is enabled)
            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                fog: false
            });
            sunSphere = new THREE.Mesh(sunGeometry, sunMaterial);
            if (!sunGlareEnabled) {
                scene.add(sunSphere);
            }

            // Create sun glare sprite (replaces sun model when enabled)
            if (sunGlareEnabled) {
                const sunGlareTexture = createGlareTexture(1.0, 0.8); // Sharp intensity
                const sunGlareMaterial = new THREE.SpriteMaterial({
                    map: sunGlareTexture,
                    color: 0xffffaa,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    fog: false
                });
                sunGlareSprite = new THREE.Sprite(sunGlareMaterial);
                sunGlareSprite.scale.set(100, 100, 1);
                scene.add(sunGlareSprite);
            }

            // Create visible moon sphere
            const moonGeometry = new THREE.SphereGeometry(8, 32, 32);
            const moonMaterial = new THREE.MeshBasicMaterial({
                color: 0xccccdd,
                fog: false
            });
            moonSphere = new THREE.Mesh(moonGeometry, moonMaterial);
            moonSphere.visible = false; // Hidden during day
            scene.add(moonSphere);

            // Create moon light (dimmer, constant intensity, more diffuse)
            moonLight = new THREE.DirectionalLight(0x8888bb, MOON_LIGHT_INTENSITY);
            moonLight.position.set(-50, 100, -50);
            scene.add(moonLight);
            scene.add(moonLight.target);

            // Create moon glare sprite (more intense than before)
            if (moonGlareEnabled) {
                const moonGlareTexture = createGlareTexture(0.6, 0.5); // More intense, still soft
                const moonGlareMaterial = new THREE.SpriteMaterial({
                    map: moonGlareTexture,
                    color: 0xccccee,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    fog: false
                });
                moonGlareSprite = new THREE.Sprite(moonGlareMaterial);
                moonGlareSprite.scale.set(50, 50, 1);
                moonGlareSprite.visible = false;
                scene.add(moonGlareSprite);
            }

            // Create star field
            starField = createStarField();
            scene.add(starField);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(worldSize * 2, worldSize * 2);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a8c3a,
                roughness: reflectionsEnabled ? 0.5 : 0.8,
                metalness: reflectionsEnabled ? 0.2 : 0
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = shadowsEnabled;
            scene.add(floor);

            // Generate terrain
            generateHeightMap();

            // Find spawn position
            let maxHeight = 0;
            let spawnX = 0, spawnZ = 0;

            for (let x = -5; x < 5; x++) {
                for (let z = -5; z < 5; z++) {
                    const h = getTerrainHeight(x, z);
                    if (h > maxHeight) {
                        maxHeight = h;
                        spawnX = x;
                        spawnZ = z;
                    }
                }
            }

            // Position camera on top of terrain
            camera.position.set(spawnX, maxHeight + PLAYER_HEIGHT, spawnZ);

            // Build initial chunks around spawn
            updateVisibleChunks(spawnX, spawnZ);
            console.log(`Built ${Object.keys(chunks).length} chunks within render distance ${RENDER_DISTANCE}`);

            createHotbar();

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('contextmenu', (e) => { e.preventDefault(); return false; });
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', onWheel, { passive: false });
            document.addEventListener('pointerlockchange', onPointerLockChange);
            window.addEventListener('resize', onWindowResize);
        }

        // ============================================
        // UI
        // ============================================
        function createHotbar() {
            const hotbar = document.getElementById('hotbar');
            hotbar.innerHTML = '';
            blockTypes.forEach((block, index) => {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot';
                if (index === selectedBlockIndex) {
                    slot.classList.add('selected');
                }

                const blockDiv = document.createElement('div');
                blockDiv.className = 'hotbar-block';
                blockDiv.style.backgroundColor = '#' + block.color.toString(16).padStart(6, '0');

                slot.appendChild(blockDiv);
                hotbar.appendChild(slot);
            });
        }

        function updateHotbar() {
            const slots = document.querySelectorAll('.hotbar-slot');
            slots.forEach((slot, index) => {
                slot.classList.toggle('selected', index === selectedBlockIndex);
            });
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================
        function onWheel(e) {
            if (!isLocked) return;
            e.preventDefault();

            if (e.deltaY > 0) {
                selectedBlockIndex = (selectedBlockIndex + 1) % blockTypes.length;
            } else {
                selectedBlockIndex = (selectedBlockIndex - 1 + blockTypes.length) % blockTypes.length;
            }
            updateHotbar();
        }

        function onMouseDown(e) {
            if (!isLocked) {
                document.body.requestPointerLock();
                return;
            }

            if (e.button === 0) {
                destroyBlock();
            } else if (e.button === 2) {
                placeBlock();
            }
        }

        function onPointerLockChange() {
            isLocked = document.pointerLockElement === document.body;
            const instructionsEl = document.getElementById('instructions');
            if (instructionsEl) {
                instructionsEl.classList.toggle('hidden', isLocked);
            }
        }

        function onMouseMove(e) {
            if (!isLocked) return;

            const movementX = e.movementX || 0;
            const movementY = e.movementY || 0;

            const sensitivity = 0.002 * MOUSE_SENSITIVITY;
            const maxMovement = 50;

            const clampedX = Math.max(-maxMovement, Math.min(maxMovement, movementX));
            const clampedY = Math.max(-maxMovement, Math.min(maxMovement, movementY));

            yaw -= clampedX * sensitivity;
            pitch -= clampedY * sensitivity;

            pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, pitch));

            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump) {
                        velocity.y = JUMP_VELOCITY;
                        canJump = false;
                    }
                    break;
            }
        }

        function onKeyUp(e) {
            switch(e.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // DAY-NIGHT CYCLE
        // ============================================
        function updateDayNightCycle(delta) {
            // Advance time
            const prevTimeOfDay = timeOfDay;
            timeOfDay += delta / DAY_CYCLE_DURATION;

            // Track day changes for seasons
            if (timeOfDay >= 1.0) {
                dayCount++;
                timeOfDay = timeOfDay % 1.0;
            }

            // Get seasonal parameters
            const { maxSunAngle, dayLengthMultiplier } = getSeasonalSunParams();

            // Adjust time for day length (longer days = sun stays up longer)
            // This warps the time so sunrise/sunset happen at different points
            const adjustedTime = adjustTimeForDayLength(timeOfDay, dayLengthMultiplier);

            // Calculate sun angle with seasonal adjustment
            const sunAngle = adjustedTime * Math.PI * 2;

            // Sun orbit parameters - maxSunAngle affects how high sun gets
            const sunDistance = 200;
            const sunHeight = Math.sin(sunAngle) * sunDistance * maxSunAngle;
            const sunHorizontal = Math.cos(sunAngle) * sunDistance;

            // Position sun in the sky relative to player
            const sunX = camera.position.x + sunHorizontal;
            const sunY = sunHeight;
            const sunZ = camera.position.z;

            // Update sun sphere position (only if not using glare)
            if (sunSphere && !sunGlareEnabled) {
                sunSphere.position.set(sunX, sunY, sunZ);
                sunSphere.visible = sunHeight > -20;
            }

            // Update sun glare sprite position
            if (sunGlareSprite) {
                sunGlareSprite.position.set(sunX, sunY, sunZ);
                sunGlareSprite.visible = sunHeight > 0;
                // Scale glare intensity based on sun height
                const glareIntensity = Math.max(0, sunHeight / (sunDistance * maxSunAngle));
                sunGlareSprite.material.opacity = glareIntensity;
            }

            // Update directional light position
            sunLight.position.set(sunX, sunY, sunZ);
            sunLight.target.position.copy(camera.position);
            sunLight.target.updateMatrixWorld();

            // Calculate sun light intensity based on sun height (brighter peak)
            let sunLightIntensity;
            if (sunHeight > 0) {
                // Daytime - peak brightness of 1.8 at noon
                const normalizedHeight = sunHeight / (sunDistance * maxSunAngle);
                sunLightIntensity = 0.4 + normalizedHeight * 1.4; // Range: 0.4 to 1.8
            } else {
                // Sun below horizon - no direct sunlight
                sunLightIntensity = 0;
            }
            sunLight.intensity = sunLightIntensity;

            // Moon position (opposite to sun)
            const moonHeight = -sunHeight;
            const moonHorizontal = -sunHorizontal;
            const moonX = camera.position.x + moonHorizontal;
            const moonY = moonHeight;
            const moonZ = camera.position.z;

            // Update moon sphere position
            if (moonSphere) {
                moonSphere.position.set(moonX, moonY, moonZ);
                // Moon visible when above horizon
                moonSphere.visible = moonHeight > -20;
            }

            // Update moon glare sprite position
            if (moonGlareSprite) {
                moonGlareSprite.position.set(moonX, moonY, moonZ);
                moonGlareSprite.visible = moonHeight > 0;
                // Moon glare is more intense but constant
                moonGlareSprite.material.opacity = 0.5;
            }

            // Update moon light position (constant intensity, diffuse)
            if (moonLight) {
                moonLight.position.set(moonX, moonY, moonZ);
                moonLight.target.position.copy(camera.position);
                moonLight.target.updateMatrixWorld();
                // Moon provides constant dim light when visible
                moonLight.intensity = moonHeight > 0 ? MOON_LIGHT_INTENSITY : 0;
            }

            // Update star field
            if (starField) {
                // Stars rotate with the world (follow time of day)
                starField.rotation.x = sunAngle;
                starField.position.copy(camera.position);

                // Stars visible at night, fade in/out at twilight
                let starOpacity = 0;
                if (sunHeight < 0) {
                    // Fade in quickly after sunset
                    const nightDepth = Math.abs(sunHeight) / (sunDistance * maxSunAngle);
                    starOpacity = Math.min(1, nightDepth * 3); // Quick fade in
                } else if (sunHeight < sunDistance * maxSunAngle * 0.1) {
                    // Very early dawn - stars still slightly visible
                    starOpacity = 1 - (sunHeight / (sunDistance * maxSunAngle * 0.1));
                }
                starField.material.opacity = starOpacity * 0.8;
            }

            // Calculate sky color with shorter red twilight
            let skyColor, fogColor, sunColor;

            if (sunHeight > 0) {
                // Daytime - bright blue sky
                const dayProgress = sunHeight / (sunDistance * maxSunAngle);
                skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0xff6b35), // Dawn orange
                    new THREE.Color(0x87ceeb), // Day blue
                    Math.min(1, dayProgress * 3) // Faster transition (was *2)
                );
                fogColor = skyColor;

                // Sun color - yellow during day, orange near horizon
                sunColor = new THREE.Color().lerpColors(
                    new THREE.Color(0xff8800), // Orange
                    new THREE.Color(0xffff88), // Pale yellow
                    dayProgress
                );
            } else {
                // Nighttime - quick transition from twilight to night
                const nightProgress = Math.abs(sunHeight) / (sunDistance * maxSunAngle);

                // Very short red/orange twilight phase
                if (nightProgress < 0.15) {
                    // Brief twilight - orange to purple
                    const twilightProgress = nightProgress / 0.15;
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0xff6b35), // Sunset orange
                        new THREE.Color(0x1a1a4a), // Twilight blue
                        twilightProgress
                    );
                } else {
                    // Full night - dark blue to near black
                    const deepNightProgress = (nightProgress - 0.15) / 0.85;
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0x1a1a4a), // Twilight blue
                        new THREE.Color(0x000011), // Deep night
                        Math.min(1, deepNightProgress * 2)
                    );
                }
                fogColor = skyColor;

                // Sun not visible at night
                sunColor = new THREE.Color(0xff8800);
            }

            // Update scene colors
            scene.background = skyColor;
            scene.fog.color = fogColor;

            // Update sun material color (only if not using glare)
            if (sunSphere && !sunGlareEnabled) {
                sunSphere.material.color = sunColor;
            }

            // Update ambient light based on time
            // During day: based on sun, during night: dim ambient + moon contribution
            let ambientIntensity;
            if (sunHeight > 0) {
                ambientIntensity = 0.2 + (sunHeight / (sunDistance * maxSunAngle)) * 0.4;
            } else {
                // Night ambient is dimmer but not pitch black
                ambientIntensity = 0.12 + (moonHeight > 0 ? 0.05 : 0);
            }
            scene.children.forEach(child => {
                if (child instanceof THREE.AmbientLight) {
                    child.intensity = ambientIntensity;
                }
            });
        }

        // Adjusts time of day to create longer/shorter days based on season
        function adjustTimeForDayLength(time, multiplier) {
            // multiplier > 1 = longer days, < 1 = shorter days
            // We want to stretch/compress the daytime portion (0.25-0.75)
            // while keeping midnight at 0/1 and sunrise/sunset roughly at 0.25/0.75

            const noonOffset = 0.25; // Time offset so 0.25 = sunrise
            const adjustedTime = time;

            // Simple adjustment: shift the sine wave to make days longer/shorter
            // This creates the effect of sun rising earlier and setting later in summer
            const dayShift = (multiplier - 1) * 0.1;

            return (adjustedTime - dayShift + 1) % 1;
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);

            // Update FPS counter
            frameCount++;
            if (time - lastFpsUpdate > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = time;
            }

            if (isLocked) {
                // Apply friction and gravity
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= GRAVITY * delta;

                // Calculate movement direction
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) {
                    velocity.z += direction.z * MOVE_SPEED * delta;
                }
                if (moveLeft || moveRight) {
                    velocity.x += direction.x * MOVE_SPEED * delta;
                }

                // Get camera-relative movement vectors
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(camera.quaternion);
                right.y = 0;
                right.normalize();

                // Calculate new position
                const newPos = camera.position.clone();
                newPos.add(forward.clone().multiplyScalar(velocity.z * delta));
                newPos.add(right.clone().multiplyScalar(velocity.x * delta));
                newPos.y += velocity.y * delta;

                // Horizontal collision
                const testPosH = camera.position.clone();
                testPosH.x = newPos.x;
                testPosH.z = newPos.z;

                if (!checkCollision(testPosH)) {
                    camera.position.x = newPos.x;
                    camera.position.z = newPos.z;
                } else {
                    velocity.x = 0;
                    velocity.z = 0;
                }

                // Vertical collision
                const testPosV = camera.position.clone();
                testPosV.y = newPos.y;

                if (newPos.y < camera.position.y) {
                    // Moving down
                    if (!checkCollision(testPosV) && testPosV.y >= PLAYER_HEIGHT) {
                        camera.position.y = testPosV.y;
                    } else {
                        velocity.y = 0;
                        canJump = true;
                        if (testPosV.y < PLAYER_HEIGHT) {
                            camera.position.y = PLAYER_HEIGHT;
                        }
                    }
                } else if (newPos.y > camera.position.y) {
                    // Moving up
                    if (!checkCollision(testPosV)) {
                        camera.position.y = testPosV.y;
                    } else {
                        velocity.y = 0;
                    }
                }

                // Floor constraint
                if (camera.position.y <= PLAYER_HEIGHT) {
                    camera.position.y = PLAYER_HEIGHT;
                    velocity.y = 0;
                    canJump = true;
                }
            }

            // Update day-night cycle
            updateDayNightCycle(delta);

            // Update visible chunks based on player position
            updateVisibleChunks(camera.position.x, camera.position.z);

            // Update debug info
            const debugEl = document.getElementById('debug');
            if (debugEl && isLocked) {
                const { cx, cz } = worldToChunk(camera.position.x, camera.position.z);
                const season = getSeasonName(getCurrentSeason());
                const dayInSeason = (dayCount % DAYS_PER_SEASON) + 1;
                debugEl.innerHTML = `FPS: ${fps}<br>Day ${dayCount + 1} (${season} ${dayInSeason}/${DAYS_PER_SEASON})<br>Chunks: ${Object.keys(chunks).length}/${activeChunks.size}<br>Render: ${RENDER_DISTANCE} chunks<br>Pos: ${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)}`;
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        // ============================================
        // MENU SETUP
        // ============================================
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = e.target.value;
        });

        document.getElementById('sensitivitySlider').addEventListener('input', (e) => {
            document.getElementById('sensitivityValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('fovSlider').addEventListener('input', (e) => {
            document.getElementById('fovValue').textContent = e.target.value;
        });

        document.getElementById('seedSlider').addEventListener('input', (e) => {
            document.getElementById('seedValue').textContent = e.target.value;
        });

        document.getElementById('renderDistanceSlider').addEventListener('input', (e) => {
            document.getElementById('renderDistanceValue').textContent = e.target.value;
        });

        document.getElementById('startButton').addEventListener('click', () => {
            MOVE_SPEED = parseFloat(document.getElementById('speedSlider').value);
            MOUSE_SENSITIVITY = parseFloat(document.getElementById('sensitivitySlider').value);
            const fov = parseFloat(document.getElementById('fovSlider').value);
            bloomEnabled = document.getElementById('bloomToggle').checked;
            reflectionsEnabled = document.getElementById('reflectionsToggle').checked;
            shadowsEnabled = document.getElementById('shadowsToggle').checked;
            sunGlareEnabled = document.getElementById('sunGlareToggle').checked;
            moonGlareEnabled = document.getElementById('moonGlareToggle').checked;
            worldSize = parseInt(document.getElementById('worldSizeSelect').value);
            worldSeed = parseInt(document.getElementById('seedSlider').value);
            RENDER_DISTANCE = parseInt(document.getElementById('renderDistanceSlider').value);

            document.getElementById('menu').classList.add('hidden');
            init(fov);
            animate();
        });
    </script>
</body>
</html>