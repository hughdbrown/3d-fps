<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First Person Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
            cursor: pointer;
        }
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #menu.hidden {
            display: none;
        }
        .menu-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
        }
        .menu-container h1 {
            margin: 0 0 30px 0;
            color: #333;
            text-align: center;
        }
        .setting-group {
            margin-bottom: 25px;
        }
        .setting-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: bold;
        }
        .setting-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        .setting-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        .setting-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
        .setting-group select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 16px;
            background: white;
            cursor: pointer;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #667eea;
            font-weight: bold;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }
        #startButton {
            width: 100%;
            padding: 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }
        #startButton:hover {
            background: #5568d3;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }
        #instructions.hidden {
            display: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
        }
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 50;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            transition: all 0.2s;
        }
        .hotbar-slot.selected {
            border-color: white;
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        .hotbar-block {
            width: 35px;
            height: 35px;
            border-radius: 3px;
        }
        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 50;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="menu">
        <div class="menu-container">
            <h1>ðŸŽ® Block Builder</h1>
            
            <div class="setting-group">
                <label>Walk Speed <span class="value-display" id="speedValue">20</span></label>
                <input type="range" id="speedSlider" min="10" max="50" value="20" step="5">
            </div>
            
            <div class="setting-group">
                <label>Mouse Sensitivity <span class="value-display" id="sensitivityValue">1.0</span></label>
                <input type="range" id="sensitivitySlider" min="0.5" max="2.0" value="1.0" step="0.1">
            </div>
            
            <div class="setting-group">
                <label>FOV <span class="value-display" id="fovValue">75</span></label>
                <input type="range" id="fovSlider" min="60" max="110" value="75" step="5">
            </div>
            
            <div class="setting-group">
                <label>Render Distance <span class="value-display" id="renderValue">4</span> chunks</label>
                <input type="range" id="renderSlider" min="2" max="8" value="4" step="1">
            </div>
            
            <div class="setting-group">
                <label>World Size</label>
                <select id="worldSizeSelect">
                    <option value="25">Small (25x25)</option>
                    <option value="100" selected>Medium (100x100)</option>
                    <option value="200">Large (200x200)</option>
                </select>
            </div>
            
            <div class="setting-group">
                <label>World Seed <span class="value-display" id="seedValue">12345</span></label>
                <input type="range" id="seedSlider" min="1" max="99999" value="12345" step="1">
            </div>
            
            <div class="setting-group">
                <label style="margin-bottom: 15px;">Graphics Options</label>
                <div class="checkbox-group">
                    <input type="checkbox" id="bloomToggle">
                    <label for="bloomToggle">Enable Bloom</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="reflectionsToggle">
                    <label for="reflectionsToggle">Enable Reflections</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="shadowsToggle" checked>
                    <label for="shadowsToggle">Enable Shadows</label>
                </div>
            </div>
            
            <button id="startButton">Start Game</button>
        </div>
    </div>
    
    <div id="instructions">
        <h2>First Person Game</h2>
        <p>Click to start</p>
        <p>Move: WASD or Arrow Keys</p>
        <p>Jump: Space Bar</p>
        <p>Look: Move Mouse</p>
        <p>Scroll: Select Block</p>
        <p>Left Click: Destroy Block</p>
        <p>Right Click: Place Block</p>
        <p>ESC to unlock cursor</p>
    </div>
    <div id="crosshair"></div>
    <div id="hotbar"></div>
    <div id="debug"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let canJump = false;
        let velocity, direction;
        const objects = [];
        
        let yaw = 0, pitch = 0;
        let isLocked = false;
        
        const PLAYER_HEIGHT = 1.8;
        const PLAYER_RADIUS = 0.5;
        const GRAVITY = 30;
        const JUMP_VELOCITY = 12;
        let MOVE_SPEED = 20;
        let MOUSE_SENSITIVITY = 1.0;
        const BLOCK_SIZE = 1;
        const REACH_DISTANCE = 10;
        const CHUNK_SIZE = 16;
        let RENDER_DISTANCE = 4;
        
        let prevTime = performance.now();
        
        // Graphics settings
        let bloomEnabled = false;
        let reflectionsEnabled = false;
        let shadowsEnabled = true;
        
        // World data
        let worldSize = 100;
        let worldSeed = 12345;
        let voxelData = {};
        let chunks = {};
        let activeChunks = new Set();
        
        const blockTypes = [
            { name: 'Stone', color: 0x808080 },
            { name: 'Wood', color: 0x8B4513 },
            { name: 'Brick', color: 0xB22222 },
            { name: 'Gold', color: 0xFFD700 },
            { name: 'Grass', color: 0x228B22 },
            { name: 'Ice', color: 0xADD8E6 },
            { name: 'Sand', color: 0xF4A460 },
            { name: 'Obsidian', color: 0x1C1C1C }
        ];
        
        let selectedBlockIndex = 0;
        
        // Seeded random number generator
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            random() {
                const x = Math.sin(this.seed++) * 10000;
                return x - Math.floor(x);
            }
        }
        
        // Perlin-like noise function
        function noise2D(x, z, seed) {
            const X = Math.floor(x);
            const Z = Math.floor(z);
            const xf = x - X;
            const zf = z - Z;
            
            const u = xf * xf * (3 - 2 * xf);
            const v = zf * zf * (3 - 2 * zf);
            
            const hash = (i, j) => {
                const n = i * 374761393 + j * 668265263;
                return (Math.sin(n + seed) * 43758.5453) % 1;
            };
            
            const a = hash(X, Z);
            const b = hash(X + 1, Z);
            const c = hash(X, Z + 1);
            const d = hash(X + 1, Z + 1);
            
            const x1 = a + u * (b - a);
            const x2 = c + u * (d - c);
            
            return x1 + v * (x2 - x1);
        }
        
        function getVoxelKey(x, y, z) {
            return `${x},${y},${z}`;
        }
        
        function getChunkKey(cx, cz) {
            return `${cx},${cz}`;
        }
        
        function worldToChunk(x, z) {
            return {
                cx: Math.floor(x / CHUNK_SIZE),
                cz: Math.floor(z / CHUNK_SIZE)
            };
        }
        
        function getHeight(x, z) {
            const scale = 0.05;
            const heightVariation = 15;
            const baseHeight = 35;
            
            let height = 0;
            height += noise2D(x * scale, z * scale, worldSeed) * heightVariation;
            height += noise2D(x * scale * 2, z * scale * 2, worldSeed) * (heightVariation / 2);
            height += noise2D(x * scale * 4, z * scale * 4, worldSeed) * (heightVariation / 4);
            
            return Math.floor(baseHeight + height);
        }
        
        function getVoxel(x, y, z) {
            const key = getVoxelKey(x, y, z);
            if (voxelData[key] !== undefined) {
                return voxelData[key];
            }
            
            const halfSize = worldSize / 2;
            const wx = x + halfSize;
            const wz = z + halfSize;
            
            if (wx < 0 || wx >= worldSize || wz < 0 || wz >= worldSize || y < 1) {
                return 0;
            }
            
            const terrainHeight = getHeight(wx, wz);
            
            if (y > terrainHeight) {
                return 0;
            }
            
            const depthFromSurface = terrainHeight - y;
            
            if (depthFromSurface === 0) {
                return 1; // Grass
            } else if (depthFromSurface <= 4) {
                return 2; // Dirt
            } else {
                return 3; // Stone
            }
        }
        
        function setVoxel(x, y, z, type) {
            const key = getVoxelKey(x, y, z);
            if (type === 0) {
                delete voxelData[key];
            } else {
                voxelData[key] = type;
            }
            
            const { cx, cz } = worldToChunk(x, z);
            updateChunk(cx, cz);
            
            // Update neighboring chunks if on edge
            const localX = x - cx * CHUNK_SIZE;
            const localZ = z - cz * CHUNK_SIZE;
            
            if (localX === 0) updateChunk(cx - 1, cz);
            if (localX === CHUNK_SIZE - 1) updateChunk(cx + 1, cz);
            if (localZ === 0) updateChunk(cx, cz - 1);
            if (localZ === CHUNK_SIZE - 1) updateChunk(cx, cz + 1);
        }
        
        function createChunkMesh(cx, cz) {
            const positions = [];
            const normals = [];
            const colors = [];
            const indices = [];
            
            const startX = cx * CHUNK_SIZE;
            const startZ = cz * CHUNK_SIZE;
            
            for (let x = startX; x < startX + CHUNK_SIZE; x++) {
                for (let z = startZ; z < startZ + CHUNK_SIZE; z++) {
                    const maxHeight = getHeight(x + worldSize / 2, z + worldSize / 2);
                    
                    for (let y = 1; y <= maxHeight; y++) {
                        const voxel = getVoxel(x, y, z);
                        if (!voxel) continue;
                        
                        let color;
                        if (voxel === 1) color = new THREE.Color(0x228B22); // Grass
                        else if (voxel === 2) color = new THREE.Color(0x8B4513); // Dirt
                        else color = new THREE.Color(0x808080); // Stone
                        
                        // Check each face
                        const faces = [
                            { dir: [0, 1, 0], corners: [[0,1,1],[1,1,1],[1,1,0],[0,1,0]] }, // top
                            { dir: [0,-1, 0], corners: [[1,0,1],[0,0,1],[0,0,0],[1,0,0]] }, // bottom
                            { dir: [1, 0, 0], corners: [[1,0,1],[1,1,1],[1,1,0],[1,0,0]] }, // right
                            { dir: [-1, 0, 0], corners: [[0,0,0],[0,1,0],[0,1,1],[0,0,1]] }, // left
                            { dir: [0, 0, 1], corners: [[0,0,1],[0,1,1],[1,1,1],[1,0,1]] }, // front
                            { dir: [0, 0,-1], corners: [[1,0,0],[1,1,0],[0,1,0],[0,0,0]] }  // back
                        ];
                        
                        for (const face of faces) {
                            const [dx, dy, dz] = face.dir;
                            const neighbor = getVoxel(x + dx, y + dy, z + dz);
                            
                            if (neighbor) continue; // Skip if neighbor exists
                            
                            const ndx = positions.length / 3;
                            
                            for (const [cx, cy, cz] of face.corners) {
                                positions.push(
                                    x + cx * BLOCK_SIZE - BLOCK_SIZE / 2,
                                    y + cy * BLOCK_SIZE - BLOCK_SIZE / 2,
                                    z + cz * BLOCK_SIZE - BLOCK_SIZE / 2
                                );
                                normals.push(dx, dy, dz);
                                colors.push(color.r, color.g, color.b);
                            }
                            
                            indices.push(
                                ndx, ndx + 1, ndx + 2,
                                ndx, ndx + 2, ndx + 3
                            );
                        }
                    }
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            
            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: reflectionsEnabled ? 0.5 : 0.7,
                metalness: reflectionsEnabled ? 0.3 : 0,
                flatShading: true
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            if (shadowsEnabled) {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
            }
            
            return mesh;
        }
        
        function updateChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            
            if (chunks[key]) {
                scene.remove(chunks[key]);
                chunks[key].geometry.dispose();
                chunks[key].material.dispose();
                delete chunks[key];
            }
            
            if (activeChunks.has(key)) {
                const mesh = createChunkMesh(cx, cz);
                chunks[key] = mesh;
                scene.add(mesh);
                objects.push(mesh);
            }
        }
        
        function updateVisibleChunks() {
            const { cx: playerCX, cz: playerCZ } = worldToChunk(
                camera.position.x,
                camera.position.z
            );
            
            const newActiveChunks = new Set();
            
            for (let cx = playerCX - RENDER_DISTANCE; cx <= playerCX + RENDER_DISTANCE; cx++) {
                for (let cz = playerCZ - RENDER_DISTANCE; cz <= playerCZ + RENDER_DISTANCE; cz++) {
                    const key = getChunkKey(cx, cz);
                    newActiveChunks.add(key);
                    
                    if (!activeChunks.has(key)) {
                        activeChunks.add(key);
                        updateChunk(cx, cz);
                    }
                }
            }
            
            // Remove chunks that are no longer visible
            for (const key of activeChunks) {
                if (!newActiveChunks.has(key)) {
                    activeChunks.delete(key);
                    if (chunks[key]) {
                        scene.remove(chunks[key]);
                        chunks[key].geometry.dispose();
                        chunks[key].material.dispose();
                        const idx = objects.indexOf(chunks[key]);
                        if (idx > -1) objects.splice(idx, 1);
                        delete chunks[key];
                    }
                }
            }
        }
        
        function init(fov) {
            velocity = new THREE.Vector3();
            direction = new THREE.Vector3();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, RENDER_DISTANCE * CHUNK_SIZE * 1.5);
            
            camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = shadowsEnabled;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = bloomEnabled ? 1.2 : 1.0;
            document.body.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            if (shadowsEnabled) {
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
            }
            scene.add(directionalLight);
            
            // Find spawn position
            const halfSize = worldSize / 2;
            let maxHeight = 0;
            let spawnX = 0;
            let spawnZ = 0;
            
            for (let x = -5; x < 5; x++) {
                for (let z = -5; z < 5; z++) {
                    const h = getHeight(halfSize + x, halfSize + z);
                    if (h > maxHeight) {
                        maxHeight = h;
                        spawnX = x;
                        spawnZ = z;
                    }
                }
            }
            
            camera.position.set(spawnX, maxHeight + PLAYER_HEIGHT, spawnZ);
            
            updateVisibleChunks();
            
            createHotbar();
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('contextmenu', onContextMenu);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', onWheel, { passive: false });
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            window.addEventListener('resize', onWindowResize);
        }
        
        function createHotbar() {
            const hotbar = document.getElementById('hotbar');
            hotbar.innerHTML = '';
            blockTypes.forEach((block, index) => {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot';
                if (index === selectedBlockIndex) {
                    slot.classList.add('selected');
                }
                
                const blockDiv = document.createElement('div');
                blockDiv.className = 'hotbar-block';
                blockDiv.style.backgroundColor = '#' + block.color.toString(16).padStart(6, '0');
                
                slot.appendChild(blockDiv);
                hotbar.appendChild(slot);
            });
        }
        
        function updateHotbar() {
            const slots = document.querySelectorAll('.hotbar-slot');
            slots.forEach((slot, index) => {
                slot.classList.toggle('selected', index === selectedBlockIndex);
            });
        }
        
        function onWheel(e) {
            if (!isLocked) return;
            e.preventDefault();
            
            if (e.deltaY > 0) {
                selectedBlockIndex = (selectedBlockIndex + 1) % blockTypes.length;
            } else {
                selectedBlockIndex = (selectedBlockIndex - 1 + blockTypes.length) % blockTypes.length;
            }
            updateHotbar();
        }
        
        function onMouseDown(e) {
            if (!isLocked) {
                document.body.requestPointerLock();
                return;
            }
            
            if (e.button === 0) {
                destroyBlock();
            } else if (e.button === 2) {
                placeBlock();
            }
        }
        
        function onContextMenu(e) {
            e.preventDefault();
            return false;
        }
        
        function getRaycastTarget() {
            const raycaster = new THREE.Raycaster();
            const dir = new THREE.Vector3(0, 0, -1);
            dir.applyQuaternion(camera.quaternion);
            raycaster.set(camera.position, dir);
            
            const step = 0.1;
            const maxDist = REACH_DISTANCE;
            
            for (let d = 0; d < maxDist; d += step) {
                const pos = camera.position.clone().add(dir.clone().multiplyScalar(d));
                const x = Math.floor(pos.x);
                const y = Math.floor(pos.y);
                const z = Math.floor(pos.z);
                
                if (getVoxel(x, y, z)) {
                    const prevPos = camera.position.clone().add(dir.clone().multiplyScalar(d - step));
                    return {
                        voxel: { x, y, z },
                        previous: {
                            x: Math.floor(prevPos.x),
                            y: Math.floor(prevPos.y),
                            z: Math.floor(prevPos.z)
                        }
                    };
                }
            }
            
            return null;
        }
        
        function placeBlock() {
            const target = getRaycastTarget();
            if (!target) return;
            
            const { x, y, z } = target.previous;
            
            const distToPlayer = new THREE.Vector2(x - camera.position.x, z - camera.position.z).length();
            const heightDiff = Math.abs(y - camera.position.y);
            
            if (distToPlayer < PLAYER_RADIUS + BLOCK_SIZE * 0.6 && heightDiff < PLAYER_HEIGHT) {
                return;
            }
            
            if (getVoxel(x, y, z)) return;
            
            let voxelType;
            const selectedColor = blockTypes[selectedBlockIndex].color;
            
            if (selectedColor === 0x808080) voxelType = 3;
            else if (selectedColor === 0x8B4513) voxelType = 2;
            else if (selectedColor === 0x228B22) voxelType = 1;
            else voxelType = 4 + selectedBlockIndex;
            
            setVoxel(x, y, z, voxelType);
        }
        
        function destroyBlock() {
            const target = getRaycastTarget();
            if (!target) return;
            
            const { x, y, z } = target.voxel;
            setVoxel(x, y, z, 0);
        }
        
        function checkCollision(newPos) {
            const x = Math.floor(newPos.x);
            const y = Math.floor(newPos.y - PLAYER_HEIGHT + 0.1);
            const z = Math.floor(newPos.z);
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = 0; dy < 3; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (getVoxel(x + dx, y + dy, z + dz)) {
                            const blockMin = new THREE.Vector3(x + dx - 0.5, y + dy - 0.5, z + dz - 0.5);
                            const blockMax = new THREE.Vector3(x + dx + 0.5, y + dy + 0.5, z + dz + 0.5);
                            
                            const playerMin = new THREE.Vector3(
                                newPos.x - PLAYER_RADIUS,
                                newPos.y - PLAYER_HEIGHT,
                                newPos.z - PLAYER_RADIUS
                            );
                            const playerMax = new THREE.Vector3(
                                newPos.x + PLAYER_RADIUS,
                                newPos.y + 0.3,
                                newPos.z + PLAYER_RADIUS
                            );
                            
                            if (playerMax.x > blockMin.x && playerMin.x < blockMax.x &&
                                playerMax.y > blockMin.y && playerMin.y < blockMax.y &&
                                playerMax.z > blockMin.z && playerMin.z < blockMax.z) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        
        function onPointerLockChange() {
            isLocked = document.pointerLockElement === document.body;
            const instructionsEl = document.getElementById('instructions');
            if (instructionsEl) {
                instructionsEl.classList.toggle('hidden', isLocked);
            }
        }
        
        function onPointerLockError() {
            console.error('Pointer lock error');
        }
        
        function onMouseMove(e) {
            if (!isLocked) return;
            
            const movementX = e.movementX || 0;
            const movementY = e.movementY || 0;
            
            const sensitivity = 0.002 * MOUSE_SENSITIVITY;
            const maxMovement = 50;
            
            const clampedX = Math.max(-maxMovement, Math.min(maxMovement, movementX));
            const clampedY = Math.max(-maxMovement, Math.min(maxMovement, movementY));
            
            yaw -= clampedX * sensitivity;
            pitch -= clampedY * sensitivity;
            
            pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, pitch));
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
        }
        
        function onKeyDown(e) {
            switch(e.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump) {
                        velocity.y = JUMP_VELOCITY;
                        canJump = false;
                    }
                    break;
            }
        }
        
        function onKeyUp(e) {
            switch(e.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        let lastChunkUpdate = 0;
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);
            
            // Update FPS counter
            frameCount++;
            if (time - lastFpsUpdate > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = time;
            }
            
            if (isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= GRAVITY * delta;
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();
                
                if (moveForward || moveBackward) {
                    velocity.z += direction.z * MOVE_SPEED * delta;
                }
                if (moveLeft || moveRight) {
                    velocity.x += direction.x * MOVE_SPEED * delta;
                }
                
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();
                
                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(camera.quaternion);
                right.y = 0;
                right.normalize();
                
                const newPos = camera.position.clone();
                const forwardMove = forward.clone().multiplyScalar(velocity.z * delta);
                const rightMove = right.clone().multiplyScalar(velocity.x * delta);
                
                newPos.add(forwardMove);
                newPos.add(rightMove);
                newPos.y += velocity.y * delta;
                
                const testPosH = camera.position.clone();
                testPosH.x = newPos.x;
                testPosH.z = newPos.z;
                
                if (!checkCollision(testPosH)) {
                    camera.position.x = newPos.x;
                    camera.position.z = newPos.z;
                } else {
                    velocity.x = 0;
                    velocity.z = 0;
                }
                
                const testPosV = camera.position.clone();
                testPosV.y = newPos.y;
                
                if (newPos.y < camera.position.y) {
                    if (!checkCollision(testPosV) && testPosV.y >= PLAYER_HEIGHT) {
                        camera.position.y = testPosV.y;
                    } else {
                        velocity.y = 0;
                        canJump = true;
                        
                        if (testPosV.y < PLAYER_HEIGHT) {
                            camera.position.y = PLAYER_HEIGHT;
                        }
                    }
                } else if (newPos.y > camera.position.y) {
                    if (!checkCollision(testPosV)) {
                        camera.position.y = testPosV.y;
                    } else {
                        velocity.y = 0;
                    }
                }
                
                if (camera.position.y <= PLAYER_HEIGHT) {
                    camera.position.y = PLAYER_HEIGHT;
                    velocity.y = 0;
                    canJump = true;
                }
                
                // Update chunks every 500ms
                if (time - lastChunkUpdate > 500) {
                    updateVisibleChunks();
                    lastChunkUpdate = time;
                }
            }
            
            // Update debug info
            const debugEl = document.getElementById('debug');
            if (debugEl && isLocked) {
                const { cx, cz } = worldToChunk(camera.position.x, camera.position.z);
                debugEl.innerHTML = `FPS: ${fps}<br>Chunks: ${activeChunks.size}<br>Pos: ${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}<br>Chunk: ${cx}, ${cz}`;
            }
            
            prevTime = time;
            renderer.render(scene, camera);
        }
        
        // Menu setup - at the end of script
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = e.target.value;
        });
        
        document.getElementById('sensitivitySlider').addEventListener('input', (e) => {
            document.getElementById('sensitivityValue').textContent = parseFloat(e.target.value).toFixed(1);
        });
        
        document.getElementById('fovSlider').addEventListener('input', (e) => {
            document.getElementById('fovValue').textContent = e.target.value;
        });
        
        document.getElementById('renderSlider').addEventListener('input', (e) => {
            document.getElementById('renderValue').textContent = e.target.value;
        });
        
        document.getElementById('seedSlider').addEventListener('input', (e) => {
            document.getElementById('seedValue').textContent = e.target.value;
        });
        
        document.getElementById('startButton').addEventListener('click', () => {
            MOVE_SPEED = parseFloat(document.getElementById('speedSlider').value);
            MOUSE_SENSITIVITY = parseFloat(document.getElementById('sensitivitySlider').value);
            const fov = parseFloat(document.getElementById('fovSlider').value);
            RENDER_DISTANCE = parseInt(document.getElementById('renderSlider').value);
            bloomEnabled = document.getElementById('bloomToggle').checked;
            reflectionsEnabled = document.getElementById('reflectionsToggle').checked;
            shadowsEnabled = document.getElementById('shadowsToggle').checked;
            worldSize = parseInt(document.getElementById('worldSizeSelect').value);
            worldSeed = parseInt(document.getElementById('seedSlider').value);
            
            document.getElementById('menu').classList.add('hidden');
            init(fov);
            animate();
        });
    </script>
</body>
</html>